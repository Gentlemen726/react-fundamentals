# Creating custom components

## 📝 Your Notes

Elaborate on your learnings here in `src/exercise/04.md`

## Background

Just like in regular JavaScript, when you want to reuse code, you write
functions. If you want to share JSX, you can do that as well. In React we call
these functions "components" and they have some special properties.

Components are functions which accept an object called "props" and return
something that is renderable (more React elements, strings, `null`, numbers,
etc.). To be clear, this is _the_ definition of a React component. That's all it
is. So I'll say it again:

> Components are functions which accept an object called "props" and return
> something that is renderable

## Exercise

Production deploys:

- [Exercise](http://react-fundamentals-next.netlify.app/isolated/exercise/04.html)
- [Final](http://react-fundamentals-next.netlify.app/isolated/final/04.html)

Let's say the DOM we want to generate is like this:

```html
<div class="container">
  <div class="message">Hello World</div>
  <div class="message">Goodbye World</div>
</div>
```

In this case, it would be cool if we could reduce the duplication for creating
the React elements for this:

```tsx
<div className="message">{children}</div>
```

So we need to make a function which accepts an object argument with a `children`
property and returns the React element. Then you can interpolate a call to that
function in your JSX.

```tsx
<div>{message('Hello World')}</div>
```

This is not how we write custom React components, but this is important for you
to understand them. We'll get to custom components in the extra credit.

📜 Read more

- [https://react.dev/learn/javascript-in-jsx-with-curly-braces](https://react.dev/learn/javascript-in-jsx-with-curly-braces)
- [https://kentcdodds.com/blog/what-is-jsx](https://kentcdodds.com/blog/what-is-jsx)

## Extra Credit

### 1. 💯 using a custom component with React.createElement

[Production deploy](http://react-fundamentals-next.netlify.app/isolated/final/04.extra-1.html)

So far we've only used `React.createElement('someString')`, but the first
argument to `React.createElement` can also be a function which returns something
that's renderable.

So instead of calling your `message` function, pass it as the first argument to
`React.createElement` and pass the `{children: 'Hello World'}` object as the
second argument.

### 2. 💯 using a custom component with JSX

[Production deploy](http://react-fundamentals-next.netlify.app/isolated/final/04.extra-2.html)

Rather than:

```tsx
element = React.createElement(message, {children: 'Hello World'})
```

I want to use JSX, even for custom components, like this:

```tsx
element = <message>Hello World</message>
```

And we're so close! Just like using JSX for regular `div`s is nicer than using
the raw `React.createElement` API, using JSX for custom components is nicer too.
Remember that it's Babel that's responsible for taking our JSX and compiling it
to `React.createElement` calls. If we try `<message>Hello World</message>,
here's what Babel will do:

```tsx
element = <message>Hello World</message>

// the desired output
element = React.createElement(message, {children: 'Hello World'})

// the actual output
element = React.createElement('message', {children: 'Hello World'})
```

So we just need a way to tell Babel how to compile our JSX so it passes the
function by its name rather than a string. We do this by how the JSX appears.
Here are a few examples of Babel output for JSX:

```tsx
element = <Capitalized /> // React.createElement(Capitalized)
element = <property.access /> // React.createElement(property.access)
element = <Property.Access /> // React.createElement(Property.Access)
element = <Property['Access'] /> // SyntaxError
element = <lowercase /> // React.createElement('lowercase')
element = <kebab-case /> // React.createElement('kebab-case')
element = <Upper-Kebab-Case /> // React.createElement('Upper-Kebab-Case')
element = <Upper_Snake_Case /> // React.createElement(Upper_Snake_Case)
element = <lower_snake_case /> // React.createElement('lower_snake_case')
```

Now let's refactor your function to a name that will make it possible to call it
by using it as a JSX component.

### 4. 💯 Custom Props

[Production deploy](http://react-fundamentals-next.netlify.app/isolated/final/04.extra-4.html)

You are the commander of your component's API. The API for your component is
"props" which is the object your component function accepts as an argument. For
example, our `Message` component uses the "special" and implicit `children`
prop. It's special because it means we can do this:

```tsx
element = <Message>Hello World</Message>
// is functionally equivalent to
element = <Message children="Hello World" />

// and this:
element = (
  <Message>
    <span>Hello</span> <span>World</span>
  </Message>
)
// is functionally equivalent to
element = <Message children={[<span>Hello</span>, ' ', <span>World</span>]} />
```

But we don't have to use the `children` prop, we can call it whatever we want.
And sometimes using something other than the `children` prop can be really
useful. For example, let's imagine a `Calculator` component that can display an
equation and it's solution, like so:

```tsx
element = <Calculator left={1} operator="+" right={2} />
// should render:
// <div>
//   <code>
//     1 + 2 = <output>3</output>
//   </code>
// </div>
```

Let's get some more practice with custom components.

This extra credit primes us for the next exercise which is a different example,
so you'll find starter code for this extra credit in `exercise/04.extra-4.html`.

## 🦉 Elaboration and Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Fundamentals%20%E2%9A%9B&e=04%3A%20Creating%20custom%20components&em=).
