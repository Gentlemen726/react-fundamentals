# Forms

## üìù Your Notes

Elaborate on your learnings here in `src/exercise/07.md`

## Background

In React, there actually aren't a ton of things you have to learn to interact
with forms beyond what you can do with regular DOM APIs and JavaScript. Which I
think is pretty awesome.

You can attach a submit handler to a form element with the `onSubmit` prop. This
will be called with the submit event which has a `currentTarget`. That
`currentTarget` is a reference to the `<form>` DOM node which has a reference to
the elements of the form which can be used to get the values out of the form!

In the extra credits for this exercise, we'll be using React hooks. If you've
never worked with hooks before don't worry, this is just an introduction. We've
got two workshops dedicated to working with them you can look forward to. This
is just to expose you to use cases hooks are intended to handle. Feel free to go
as deep as you like on these extra credits by checking Dominic's üìú references,
just remember you don't have to know it all in this workshop. We'll get to it
soon!

## Exercise

Production deploys:

- [Exercise](http://react-fundamentals-next.netlify.app/isolated/exercise/07.tsx)
- [Final](http://react-fundamentals-next.netlify.app/isolated/final/07.tsx)

In this exercise, we have a form where you can submit a username and then you'll
get an "alert" showing what you typed.

ü¶â There are several ways to get the value of the name input:

- Via their index: `event.currentTarget.elements[0].value`
- Via the elements object by their `name` or `id` attribute:
  `event.currentTarget.elements.usernameInput.value`
- There's another that I'll save for the extra credit

ü¶∫ Depending on how you implement this, your typings will be slightly different
because TypeScript isn't _quite_ smart enough to know what elements your form
has. Give it your best shot and try a few combinations. If you get stuck, you
can peak at the final solution to give you a tip. Also we'll dive a little
deeper into improving this in the extra credit.

ü¶∫ Here's a little TS tip, if you have a variable (like, I don't know, let's say
a `from`) and want to add properties to its type, you can do something like
this:

```tsx
const a = {b: {c: 'd'}}
const b = a.b as typeof a.b & {e: string}
console.log(b.e) // <-- this compiles fine
```

## Extra Credit

### 1. üíØ using refs

[Production deploy](http://react-fundamentals-next.netlify.app/isolated/final/07.extra-1.tsx)

Another way to get the value is via a `ref` in React. A `ref` is an object that
stays consistent between renders of your React component. It has a `current`
property on it which can be updated to any value at any time. In the case of
interacting with DOM nodes, you can pass a `ref` to a React element and React
will set the `current` property to the DOM node that's rendered.

So if you create an `inputRef` object via `React.useRef(null)`, you could access
the value via: `inputRef.current.value` (üìú
https://reactjs.org/docs/hooks-reference.html#useref)

Try to get the usernameInput's value using a ref.

ü¶∫ `React.useRef` is a generic function, so you can pass the type you plan the
`current` to have. In our case, that's an `HTMLInputElement`.

### 2. üíØ improve form typing

[Production deploy](http://react-fundamentals-next.netlify.app/isolated/final/07.extra-2.tsx)

Let's go back to the solution we have before the `useRef`:

```tsx
function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
  event.preventDefault()
  const form = event.currentTarget
  const formElements = form.elements as typeof form.elements & {
    usernameInput: HTMLInputElement
  }
  onSubmitUsername(formElements.usernameInput.value)
}
```

I have two problems with this:

1. It's a bit verbose to do it inline like that and therefore distracts from the
   intent of the function
2. If I wanted to do this in multiple places I'd either have to duplicate that
   or extract it into a type somehow.

We're the ones in charge of the type of `event.currentTarget`. It's what we pass
to the `React.FormEvent` generic. So what if we could extend `HTMLFormElement`
interface and override the `elements` to be a type that had our form elements?

In this extra credit, you'll actually need first to create an interface that
extends `HTMLFormControlsCollection` which you'll use as the `elements` override
for your interface that extends `HTMLFormElement`.

For some extra reading on this, check:
[How to type a React form onSubmit handler](https://epicreact.dev/how-to-type-a-react-form-on-submit-handler)

### 3. üíØ Control the input value

[Production deploy](http://react-fundamentals-next.netlify.app/isolated/final/07.extra-3.tsx)

Sometimes you have form inputs which you want to programmatically control. Maybe
you want to set their value explicitly when the user clicks a button, or maybe
you want to change what the value is as the user is typing.

This is why React supports Controlled Form inputs. Pretty much any time you want
the value of the input to be different from what the user typed, you need
Controlled Form inputs. So far in our exercises, all of the form inputs have
been "uncontrolled" which means that the browser is maintaining the state of the
input by itself and we can be notified of changes and "query" for the value from
the DOM node.

If we want to explicitly update that value we could do this:
`inputNode.value = 'whatever'` but that's pretty imperative. Instead, React
allows us to programmatically set the `value` prop on the input like so:

```tsx
<input value={myInputValue} />
```

Once we do that, React ensures that the value of that input can never differ
from the value of the `myInputValue` variable. The trick is where to store the
`myInputValue` and how to let React know that you updated that value so it needs
to update the UI. We need to manage some state. We'll dive deeper into this in
future workshops, but here's a quick intro to managing state with React.

With React, the way you use state is via a special "hook" called `useState`.
Here's a simple example of what that looks like:

```jsx
function Counter() {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(count + 1)
  return <button onClick={increment}>{count}</button>
}
```

`React.useState` accepts a default initial value and returns an array. Typically
you'll destructure that array to get the state and a state updater function.

In our example above, `count` is the actual value, `setCount` is how you update
the value, and the value we pass to `useState` is the initial value.

Again, we'll get in more depth on React hooks soon. This example should be
enough to get you going, but if you'd like to dive deeper, feel free to checkout
the official docs: üìú https://reactjs.org/docs/hooks-state.html

üë®‚Äçüíº The input we've been working with is used inside a user registration form and
our users have been complaining that they can't ever think of good usernames
when signing up. So we want you to add a "Random" button that will auto-fill the
username input with a random value. üßù‚Äç‚ôÄÔ∏è Your co-worker already created a utility
function that can give you a random username which you can import into your file
with: `import {getRandomUsername} from '../utils'`.

So for our feature to work we'll need three things:

1. Component state to store the dynamic values (the value of the `username`)
2. An `onChange` handler on the input so when the user manually updates the
   value we can keep our `username` state up-to-date.
3. A button with an `onClick` handler on it to update the `username` to a random
   username (which we'll get by calling that `getRandomUsername()` function).

üí∞ This one's a little more tricky, so here are a few things you need to do to
make this work:

1. At the top of our component, create the state (üí∞
   `const [username, setUsername] = React.useState('')`).
2. Create a `handleChange` function that accepts the change `event` and uses
   `event.currentTarget.value` to get the value of the input and sets that to
   the username via `setUsername`. (ü¶∫ TS tip: Remember this event is a
   `ChangeEvent` and will be triggered on an `HTMLInputElement`, not the form).
3. Create a `handleRandomClick` function that calls `setUsername` with
   `getRandomUsername()`.
4. Create a button that says "Random" and set it's `onClick` to your
   `handleRandomClick` function
5. Add the `value={username}` prop to the `input`
6. Set the `onChange` prop of the `input` to your `handleChange` function.

If it's unclear what's expected, scroll up to the "Production deploy" for this
extra credit so you can play around with how this is supposed to work.

Note: you can definitely solve this one while keeping the `useRef` in place, but
in my solution I removed `useRef` and went with
`event.currentTarget.elements.usernameInput.value` approach. Feel free to do
whatever you prefer.

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Fundamentals%20%E2%9A%9B&e=07%3A%20Forms&em=).
